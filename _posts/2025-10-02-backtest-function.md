---
title: '回测实现之路（一）'
date: 2025-10-02
permalink: /posts/2025/10/quant/backtest-function/
tags:
  - Quant
  - Backtest
---

前两天学长刚劝我们手写一个回测框架来加深对细节的理解，结果今天MATH 507的第二次作业需要写一个回测框架。虽然不是第一次写，但之前写的时候要么是借用AI写了一部分，要么是考虑的例子比较平凡，没有自顶向下系统的思考过回测流程。

这次作业特别好的是给了一些不常见的例子，让我思考如何抽象整个流程。

# 1. 最简单的回测函数

我们这里先考虑最简单的情况，在这里先不考虑手续费、滑点、停牌、企业财年不同等因素，且使用最平凡的one-period optimization. 即t时刻决定从t到t+1的持仓，而不是确定t到t+1, t+1到t+2, ..., t+N-1到t+N共N期的持仓。

整体的思路是：
for rebalance_dates:
1. 计算从t到t+1的持仓w_t
2. 计算收益，并保存

为了计算1，我们通常需要**获取过去一个时间窗口（lookback）的数据**，比如过去一年、过去一个月、过去一周的收益率动量, ROIC（from 财报）, 自由现金流/市值 ...

同时我们的选股池可能也并非总是全市场，我们可能会根据一些原则从初始选股池中筛选出一个子集，在子集上分配权重

于是，流程可以写作
for rebalance_dates:
0. 获取lookback窗口中所需的数据
1. 计算从t到t+1的持仓w_t
2. 计算收益，并保存

# 2. 从一期到多期

之前我们是在t时刻只考虑从t到t+1的持仓，然后等到t+1时再决定t+1到t+2的持仓 ... 这叫one-period optimization。有时候，我们需要一下决定多期的持仓（multi-period optimization），比如在t时刻就=决定从t到t+1, t+1到t+2, ..., t+4到t+5共N期的持仓。

为什么要这么操作呢？我们稍后再说。

这个时候我们上述的回测流程就需要发生一些改变。

for rebalance_dates:
1. if horizon起始日：
    1. 获取lookback窗口中所需的数据
    2. 计算N期持仓
2. 根据预先计算的持仓调整
3. 计算收益

# 3. 抽象
现在我们有两种回测流程，我们如何将这两种流程放到一个框架中呢？

一种做法是，我们将计算持仓和计算收益分开来，通过**两次loop**的方式，先计算得到持仓表，然后根据这个持仓表计算收益。这某种程度上避免了原来 **1-loop** 方法中计算当期权重，还是搜索权重的纠结。

沿着这个思路，我们还能注意到每期调用api获取数据是很麻烦的。获取数据也可以这一步提前储存好。